1. контекстное переключение задач
Задачу распараллеливают на подзадачи, и из них 
выстраивается очередь.
Но очередь имеет вид "2 1 2 3 3 1 ...", а не "1 2 3 ..."


2. организация параллелизма
- multi-proccessing
несколько процессов работают над одной задачей (mp)
процесс оснащен всем, чем можно (код, данные, ресурсы)
у каждого процеса свои данные.
- multi-threading 
работаем с процессом, в котором некоторые участки кода 
работают независимо 
потоки могут между собой взаимодействовать
у процессов общие данные 

принципы распараллеливания:
    - по данным (разбиваем массив по кусочкам, потом объединяем результаты)
    - по задачам (один сортирует, второй музыку играет, третий еще что-то)
    

3. влияние на производительность параллельных алгоритмов
- количество ядер 
- конкуренция за данные
- безопасность относительно исключений
- закон Амдала
S = T1 / Tn <= 1/a -- ускорение, a-- доля не ||-го кода
не учитывает что ядра умеют передавать данные
 


4. асинхронное исполнение
future -- статический объект, который предоставляет 
значение с помощью get

инструменты для работы с ним:
 - async  
запускает в потоке функцию, результат завернет в 
объект типа future
std::future<int> result = std::async([](){return 42;});

 - packeged_task  - учитывает информацию в потоке
std::packeged_task<int()> task([]()/*lambda,functor*/{return 42;});
auto result = task.get_future();
std::thread(std::move(task)).detach();
...
X = result.get(); 

 - promice 
можно работать, будто это известное значение
atd::promise<int> p;
auto result =  p.get_future;
std::thred([](std::promise<int>&p){})
...
X = result.get(); 


5. замена послед-ой реализации алгоритма на параллельную
Нужно учитывать объем работы. Стоит ли это распараллеливания.






